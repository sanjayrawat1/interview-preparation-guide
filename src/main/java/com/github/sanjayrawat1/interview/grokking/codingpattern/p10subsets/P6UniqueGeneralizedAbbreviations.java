package com.github.sanjayrawat1.interview.grokking.codingpattern.p10subsets;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * https://leetcode.com/problems/generalized-abbreviation/
 * <p>
 * Given a word, write a function to generate all of its unique generalized abbreviations.
 * <br>
 * A generalized abbreviation of a word can be generated by replacing each substring of the word with the
 * count of characters in the substring. Take an example of "ab" which has four substrings: "", "a", "b",
 * "ab". After replacing these substrings in the actual word by the count of characters, we get all the
 * generalized abbreviations: "ab", "1b", "a1", and "2".
 * <br>
 * Note: All contiguous characters should be considered one substring, e.g., we can't take "a" and "b" as
 * substrings to get "11"; since "a" and "b" are contiguous, we should consider them together as one substring
 * to get an abbreviation "2".
 *
 * @author Sanjay Singh Rawat
 */
public class P6UniqueGeneralizedAbbreviations {

    private static class AbbreviatedWord {

        String str;

        int start;

        int count;

        public AbbreviatedWord(String str, int start, int count) {
            this.str = str;
            this.start = start;
            this.count = count;
        }
    }

    /**
     * Following a BFS approach, we will abbreviate one character at a time. At each step, we have two options:
     * <ol>
     *     <li> Abbreviate the current character or
     *     <li> Add the current character to the output and skip the abbreviation.
     * </ol>
     * Following these two rules, let's abbreviate BAT:
     * <ol>
     *     <li> Start with an empty word: ""
     *     <li> At every step, we will take all the combinations from the previous step and apply the two abbreviation
     *          rules to the next character.
     *     <li> Take the empty word from the previous step and add the first character to it. We can either abbreviate
     *          the character or add it (by skipping abbreviation). This gives us two new words: "_", "B".
     *     <li> In the next iteration, let's add the second character. Applying the two rules on "_" will give us "_ _"
     *          and "1A". Applying the above rules to the other combination "B" gives us "B_" and "BA".
     *     <li> The next iteration will give us: "_ _ _", "2T", "1A_", "1AT", "B_ _", "B1T", "BA_", "BAT".
     *     <li> The final iteration will give us: "3", "2T", "1A1", "1AT", "B2", "B1T", "BA1", "BAT"
     * </ol>
     * <li> Since we had two options for each character, we will have a maximum of 2ᴺ combinations. If you
     *      see the visual representation of BAT closely, you will realize that it is equivalent to a
     *      binary tree, where each node has two children. This means that we will have 2ᴺ leaf nodes and
     *      2ᴺ-1 intermediate nodes, so the total number of elements pushed to the queue will be 2ᴺ + 2ᴺ-1,
     *      which is asymptotically equivalent to O(2ᴺ). While processing each element, we do need to
     *      concatenate the current string with a character. This operation will take O(N), so the overall
     *      time complexity of our algorithm will be O(N*2ᴺ).
     * <li> All the additional space used by our algorithm is for the output list. Since we can’t have more
     *      than O(2ᴺ) combinations, the space complexity of our algorithm is O(N*2ᴺ).
     */
    public static List<String> generateGeneralizedAbbreviation(String word) {
        List<String> abbreviations = new ArrayList<>();
        Deque<AbbreviatedWord> queue = new ArrayDeque<>();
        queue.offer(new AbbreviatedWord("", 0, 0));

        while (!queue.isEmpty()) {
            AbbreviatedWord abbreviatedWord = queue.poll();
            if (abbreviatedWord.start == word.length()) {
                if (abbreviatedWord.count != 0) {
                    abbreviatedWord.str += abbreviatedWord.count;
                }
                abbreviations.add(abbreviatedWord.str);
            } else {
                // continue abbreviating by incrementing the current abbreviation count
                queue.offer(new AbbreviatedWord(abbreviatedWord.str, abbreviatedWord.start + 1, abbreviatedWord.count + 1));

                // restart abbreviating, append the count and the current character to the string
                if (abbreviatedWord.count != 0) {
                    abbreviatedWord.str += abbreviatedWord.count;
                }

                String newWord = abbreviatedWord.str + word.charAt(abbreviatedWord.start);
                queue.offer(new AbbreviatedWord(newWord, abbreviatedWord.start + 1, 0));
            }
        }
        return abbreviations;
    }

    public static List<String> generateGeneralizedAbbreviationRecursive(String word) {
        List<String> abbreviations = new ArrayList<>();
        generateAbbreviationRecursive(word, "", 0, 0, abbreviations);
        return abbreviations;
    }

    private static void generateAbbreviationRecursive(String word, String abbreviatedWord, int start, int count, List<String> abbreviations) {
        if (start == word.length()) {
            if (count != 0) {
                abbreviatedWord += count;
            }
            abbreviations.add(abbreviatedWord);
        } else {
            // continue abbreviating by incrementing the current abbreviation count
            generateAbbreviationRecursive(word, abbreviatedWord, start + 1, count + 1, abbreviations);

            // restart abbreviating, append the count and the current character to the string
            if (count != 0) {
                abbreviatedWord += count;
            }

            String newWord = abbreviatedWord + word.charAt(start);
            generateAbbreviationRecursive(word, newWord, start + 1, 0, abbreviations);
        }
    }

    public static void main(String[] args) {
        assertThat(generateGeneralizedAbbreviation("BAT"))
                .containsExactlyInAnyOrder("BAT", "BA1", "B1T", "B2", "1AT", "1A1", "2T", "3");
        assertThat(generateGeneralizedAbbreviation("code"))
                .containsExactlyInAnyOrder("code", "cod1", "co1e", "co2", "c1de", "c1d1", "c2e", "c3", "1ode", "1od1", "1o1e", "1o2", "2de", "2d1", "3e", "4");

        assertThat(generateGeneralizedAbbreviationRecursive("BAT"))
                .containsExactlyInAnyOrder("BAT", "BA1", "B1T", "B2", "1AT", "1A1", "2T", "3");
        assertThat(generateGeneralizedAbbreviationRecursive("code"))
                .containsExactlyInAnyOrder("code", "cod1", "co1e", "co2", "c1de", "c1d1", "c2e", "c3", "1ode", "1od1", "1o1e", "1o2", "2de", "2d1", "3e", "4");
    }
}
